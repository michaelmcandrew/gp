<?php
/*
 * This module implements access for local party membership secretaries to the
 * records of contacts (members and supporters) in their own local party area.
 *
 * It checks if the logged in user has the relationship of Membership secretary
 * to any local party, then gives access to those contacts.
 *
 * NOTE: The relationship ids are hard-coded in get_local_party_id() below.
 */

/*
 * Implements hook_civicrm_aclWhereClause().
 *
 * Defines the group of contacts that the local party membership secretary
 * should have access to.
 */

 
function gpew_local_party_access_civicrm_aclWhereClause($type, &$tables, &$whereTables, &$contactID, &$where) {
  // 
  // Note that CiviCRM checks the database table civicrm_acl_contact_cache
  // and will only call this hook if there are no cached contacts defined
  // for the logged-in user.
  // Therefore, when testing this hook, please clear the civicrm cache,
  // otherwise it will appear that your changes are making no difference.
  //
  // $type tells us if civicrm is asking for VIEW or EDIT rights.
  // 
  // When the page is trying to view a contact, then $type = 2 (CRM_ACL_API::VIEW)
  // When the page is trying to edit a contact, then $type = 1 (CRM_ACL_API::EDIT)
  // These are defined as constants in CRM/ACL/API.php
  // See: http://forum.civicrm.org/index.php/topic,21187.0.html
  //
  if (($type == CRM_ACL_API::VIEW) || ($type == CRM_ACL_API::EDIT)) {
    // 
    // The starting point for this code was:
    // sites/all/modules/civicrm/drupal/civitest.module.sample
    // function civitest_civicrm_aclWhereClause
    //
    // There is a useful discussion here:
    // http://forum.civicrm.org/index.php/topic,23234.msg100593.html
    //
    if ( ! $contactID ) {
      return;
    }
    // 
    // This was the tricky bit to work out.
    // contact_a.id comes as part of the preceding query, which we are now 
    // appending to.
    //
    // In fact, you can see where the preceding query is generated by going to:
    // CRM/Contact/BAO/Contact/Permission.php
    // Search for '$permission'. Nearby, you will see the SELECT statement we 
    // are appending to.
    // 
    // A good strategy here is to work out in advance what sql you think would
    // work, and execute it against the database using phpmyadmin.
    //
    // If we want to grant access to a set of contacts we can do this.
    // SELECT DISTINCT contact_a.id
    // FROM `civicrm_contact` contact_a
    // WHERE contact_a.id IN (27320,27321,27322,27323)
    //
    // In this case, the $where clause that we return would be:
    // 'contact_a.id IN (27320,27321,27322,27323)'
    //
    // The key thing to remember is that contact_a is part of the query which is
    // in the process of being created; contact_a is not part of what we are
    // doing, it's what came already.
    //

    // _get_local_party_ids returns an array of local party ids.
    // $type is either CRM_ACL_API::EDIT or CRM_ACL_API::VIEW
    $party_ids = _get_local_party_ids($contactID, $type);
    if(empty($party_ids['local']) AND empty($party_ids['regional'])){
      return;
    }
      // We only want to proceed with the aclWhereClause if the logged in contact
    // has access to at least one local party.

    $contact_ids = _get_contact_ids($party_ids['local'], $party_ids['regional']);
    // implode $contact_ids into a comma separated string
    $contact_ids_csv = implode(',', $contact_ids);

    $where = "contact_a.id IN ($contact_ids_csv)";
  }
}

/*
 * Implements civicrm_buildForm()
 */
function gpew_local_party_access_civicrm_buildForm($formName, &$form) {
  /*
   * We are using the simple email form with an extra querystring parameter.
   *
   * This is the form we get to when we click Contacts > New Email.
   *
   * civicrm/activity/email/add?atype=3&action=add&reset=1&context=standalone&recipients=current-members
   *
   * Note the last querystring element, which is not CiviCRM. We've added this.
   * recipients=current-members
   * It determines what subset of contacts are added to the form.
   *
   */
  if ($formName == 'CRM_Contact_Form_Task_Email') {
    // We expect recipients appended to the query string
    // e.g. &recipients=all-members
    $recipients = $GLOBALS['_GET']['recipients'];

    if (!isset($GLOBALS['_GET']['recipients'])) {
      return;
    }

    // Determine the logged in user
    civicrm_initialize();
    global $user;
    $uid = $user->uid;
    $params = array(
      'version' => '3',
      'uf_id' => $uid,
      'return' => 'contact_id',
    );
    $contactID = civicrm_api('UFMatch', 'getvalue', $params);

    $local_party_ids = _get_local_party_ids($contactID);

    if (empty($local_party_ids)) {
      return;
    }
    
    $local_party_ids_csv = implode(',', array_merge($local_party_ids['local'],$local_party_ids['regional']));

    $sql_members = "
      SELECT civicrm_contact.id 
      FROM civicrm_contact
      LEFT JOIN civicrm_value_gpew_party_information partyMembershipTable
      ON civicrm_contact.id = partyMembershipTable.entity_id
      LEFT JOIN civicrm_membership
      ON civicrm_membership.contact_id = civicrm_contact.id
      WHERE partyMembershipTable.local_party_id IN ($local_party_ids_csv)
    ";
    // If the user is not in a relationship with the local party, then return.
    // we expect $sql to be something like this:
    // SELECT contact_a.id FROM `civicrm_contact` contact_a 
    // LEFT JOIN civicrm_value_gpew_party_information partyMembershipTable 
    // ON contact_a.id = partyMembershipTable.entity_id
    // WHERE partyMembershipTable.local_party_id IN (22212,22213)

    switch ($recipients) {
      case 'current-members':
        $sql_members .= " AND ( ";
        // status_id 1 = New
        $sql_members .= "     civicrm_membership.status_id = 1 ";
        // status_id 2 = Current
        $sql_members .= "  OR civicrm_membership.status_id = 2 ";
        // status_id 3 = Grace
        $sql_members .= "  OR civicrm_membership.status_id = 3 ";
        $sql_members .= " ) ";
        break;

      case 'new-members':
        $sql_members .= " AND ( ";
        // status_id 1 = New
        $sql_members .= "     civicrm_membership.status_id = 1 ";
        $sql_members .= " ) ";
        break;

      case 'grace-period-members':
        $sql_members .= " AND ( ";
        // status_id 3 = Grace
        $sql_members .= "     civicrm_membership.status_id = 3 ";
        $sql_members .= " ) ";
        break;

      case 'expired-members':
        $sql_members .= " AND ( ";
        // status_id 4 = Expired
        $sql_members .= "     civicrm_membership.status_id = 4 ";
        $sql_members .= " ) ";
        break;

      case 'all-members':
        // Do nothing - all-members is the default SQL
        break;

      case 'supporters':
        // TODO: Different SQL needed for constituents who aren't members
        break;

      default:
        // recipients value on the querystring is not valid
        return;
    }
    
    $sql_members .= " ORDER BY civicrm_contact.sort_name ";

    $dao_members = CRM_Core_DAO::executeQuery( $sql_members, CRM_Core_DAO::$_nullArray );
    
    if ($dao_members->N > CRM_Contact_Form_Task_EmailCommon::MAX_EMAILS_KILL_SWITCH) {
      CRM_Core_Error::fatal( ts( 'Please do not use this task to send a lot of emails (greater than %1). We recommend using CiviMail instead.', array( 1 => CRM_Contact_Form_Task_EmailCommon::MAX_EMAILS_KILL_SWITCH ) ) );
    }

    while ( $dao_members->fetch( ) ) {
      $member_ids[] = $dao_members->id;
    }

    $form->_contactIds = $member_ids;

    /*
     * Here is some pasted code from
     * CRM/Contact/Form/Task/EmailCommon.php
     * line 185 onwards on version 3.3.5
     *
     * It takes $form->_contactIds and creates the toContact variable
     * which is used by the template.
     *
     * What does this do?
     * It lets us inject new items into the email To field.
     * We populate an array form->_contactIds
     * these contactIds are sent to the template in a way that the template
     * can populate the facebook-style 'To' field on 
     * civicrm/activity/email/add
     *
     * The line that does this is:
     * $form->assign('toContact', json_encode( $toArray ) );
     * ... this assigns a value to a variable in the .tpl file.
     *
     * See: civicrm/templates/CRM/Contact/Form/Task/Email.tpl
     * Search for: toContact
     */

    	//if ( is_array ( $form->_contactIds ) && $toSetDefault ) {
    	if ( is_array ( $form->_contactIds ) ) {
            $returnProperties = array( 'sort_name'             => 1, 
                                       'email'                 => 1, 
                                       'do_not_email'          => 1, 
                                       'is_deceased'           => 1,
                                       'on_hold'               => 1, 
                                       'display_name'          => 1, 
                                       'preferred_mail_format' => 1 );
        
            require_once 'CRM/Mailing/BAO/Mailing.php';
            
            list( $form->_contactDetails ) = CRM_Mailing_BAO_Mailing::getDetails( $form->_contactIds, $returnProperties, false, false );

            // make a copy of all contact details
            $form->_allContactDetails = $form->_contactDetails;
        
            foreach ( $form->_contactIds as $key => $contactId ) {
                $value = $form->_contactDetails[$contactId];
                if ( $value['do_not_email'] || empty( $value['email'] ) || CRM_Utils_Array::value( 'is_deceased', $value ) || $value['on_hold'] ) {
                    $suppressedEmails++;

                    // unset contact details for contacts that we won't be sending email. This is prevent extra computation 
                    // during token evaluation etc.
                    unset( $form->_contactDetails[$contactId] );
                } else {
                    if ( empty( $form->_toContactEmails ) ) {
                        $email = $value['email'];
                    } else {
                        $email = $form->_toContactEmails[$key];
                    }
                    $toArray[] = array( 'name' => '"'. $value['sort_name'] .'" &lt;' .$email .'&gt;',
                                        'id'   => "$contactId::{$email}" );
                }
            }

    		if ( empty( $toArray ) ) {
    			CRM_Core_Error::statusBounce( ts('Selected contact(s) do not have a valid email address, or communication preferences specify DO NOT EMAIL, or they are deceased or Primary email address is On Hold.' ));
    		}
    	}

		$form->assign('toContact', json_encode( $toArray ) );
		$form->assign('suppressedEmails', $suppressedEmails);
        
        $form->assign('totalSelectedContacts',count($form->_contactIds));

    /*
     * end pasted code
     */


    // ensure that only one email is displayed in the from-email box
    if ($form->elementExists('fromEmailAddress')) {
      $fromEmailAddressElement =& $form->getElement('fromEmailAddress');
      $options =& $fromEmailAddressElement->_options;
      // retain $options[0], unset the rest
      $options_count = count($options);
      for ($i = 1; $i < $options_count; $i++) {
        unset($options[$i]);
      }
    }
  } //$formName == 'CRM_Contact_Form_Task_Email'
}

function _get_local_party_ids($contactID, $permission_type) {
  require_once('CRM/ACL/API.php');  
  // These are the relationships which are allowed access to local party 
  // reports
  $LOCAL_PARTY_VIEW = 25;
  $LOCAL_PARTY_EDIT = 26;
  $REGIONAL_PARTY_VIEW = 27;
  $REGIONAL_PARTY_EDIT = 28;

  // This is the relationship which connects regional parties with their 
  // respective local parties
  $LOCAL_PARTY_REGION = 23;

  $regional_party_ids = array();
  $local_party_ids = array();

  // Let's look first at EDIT permissions for regional party.
  $sql_regional_party  = "SELECT contact_id_b";
  $sql_regional_party .= " FROM civicrm_relationship";
  $sql_regional_party .= " WHERE contact_id_a = $contactID";

  $sql_regional_party_edit  = $sql_regional_party;
  $sql_regional_party_edit .= " AND relationship_type_id = $REGIONAL_PARTY_EDIT";
  $sql_regional_party_edit .= " AND is_active = 1";

  $dao_regional_party_edit = CRM_Core_DAO::executeQuery($sql_regional_party_edit);

  while ($dao_regional_party_edit->fetch()) {
    $regional_party_ids[] = $dao_regional_party_edit->contact_id_b;
  }

  // Let's check VIEW permissions for regional party.
  // Only need to do this if VIEW rights are being requested by CiviCRM.
  if ($permission_type == CRM_ACL_API::VIEW) {
    $sql_regional_party_view = $sql_regional_party;
    $sql_regional_party_view .= " AND relationship_type_id = $REGIONAL_PARTY_VIEW";
    $sql_regional_party_view .= " AND is_active = 1";

    $dao_regional_party_view = CRM_Core_DAO::executeQuery($sql_regional_party_view);

    while ($dao_regional_party_view->fetch()) {
      if (!in_array($dao_regional_party_view->contact_id_b, $regional_party_ids)) {
        $regional_party_ids[] = $dao_regional_party_view->contact_id_b;
      }
    }
  }

  // So far, we know $local_party_ids for those with regional party access.
  // Now, let's check for local party access.

  // Let's check for EDIT permissions for local party.
  // This is a shameless copy-and-paste from the code above for regional.
  $sql_local_party  = "SELECT contact_id_b";
  $sql_local_party .= " FROM civicrm_relationship";
  $sql_local_party .= " WHERE contact_id_a = $contactID";

  $sql_local_party_edit  = $sql_local_party;
  $sql_local_party_edit .= " AND relationship_type_id = $LOCAL_PARTY_EDIT";
  $sql_local_party_edit .= " AND is_active = 1";

  $dao_local_party_edit = CRM_Core_DAO::executeQuery($sql_local_party_edit);

  while ($dao_local_party_edit->fetch()) {
    if (!in_array($dao_local_party_view->contact_id_b, $local_party_ids)) {
      $local_party_ids[] = $dao_local_party_edit->contact_id_b;
    }
  }

  // Let's check VIEW permissions for local party.
  // Only need to do this if VIEW rights are being requested by CiviCRM.
  if ($permission_type == CRM_ACL_API::VIEW) {
    $sql_local_party_view = $sql_regional_party;
    $sql_local_party_view .= " AND relationship_type_id = $LOCAL_PARTY_VIEW";
    $sql_local_party_view .= " AND is_active = 1";

    $dao_local_party_view = CRM_Core_DAO::executeQuery($sql_local_party_view);

    while ($dao_local_party_view->fetch()) {
      if (!in_array($dao_local_party_view->contact_id_b, $local_party_ids)) {
        $local_party_ids[] = $dao_local_party_view->contact_id_b;
      }
    }
  }

  return array('local'=>$local_party_ids, 'regional'=>$regional_party_ids);
}

function _get_contact_ids($local_party_ids=array(), $regional_party_ids=array()) {
  // Returns all contacts for a particular party.
  // Currently, this means members.
  // In future, we also want to return supporters as well.
  if(empty($local_party_ids) AND empty($regional_party_ids)){
    return array();
  }
  $where=$join='';
  $member_ids = array();
  if(count($regional_party_ids)){
    $join.=" LEFT JOIN civicrm_value_gpew_party_information AS regional_party ON civicrm_contact.id=regional_party.entity_id";
    $where.= " OR regional_party.regional_party_id IN (".implode(',', $regional_party_ids).') ';
  }
  if(count($local_party_ids)){
    $join.=" LEFT JOIN civicrm_value_gpew_party_information AS local_party ON civicrm_contact.id=local_party.entity_id";
    $where.= " OR local_party.local_party_id IN (".implode(',', $local_party_ids).') ';
  }
  $local_party_ids_csv = implode(',', $local_party_ids);
  $sql_members = "
    SELECT civicrm_contact.id 
    FROM civicrm_contact
    {$join}
    WHERE 0 {$where}";
    //echo $sql_members;exit;
  $dao_members = CRM_Core_DAO::executeQuery($sql_members);
  while ($dao_members->fetch()) {
    $member_ids[] = $dao_members->id;
  }
  // We also return the local party ids, because we allow access to view/edit
  // the local party also
  $contact_ids = array_merge($member_ids, $local_party_ids, $regional_party_ids);
  return $contact_ids;
}
